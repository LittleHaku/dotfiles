#!/bin/bash

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color
OVERWRITE='\e[1A\e[K'

# Emoji/symbols
CHECK_MARK="${GREEN}✓${NC}"
X_MARK="${RED}✗${NC}"
ARROW="${BLUE}▶${NC}"

# Variables
DOTFILES_DIR="$HOME/dotfiles"
DOTFILES_REPO_HTTPS="https://github.com/LittleHaku/dotfiles.git"
DOTFILES_REPO_SSH="git@github.com:LittleHaku/dotfiles.git"
SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
WINDOWS_SSH_DIR=""
TASK=""

# Task management functions
function __task {
    if [[ $TASK != "" ]]; then
        printf "${OVERWRITE}${CHECK_MARK} ${GREEN}${TASK}${NC}\n"
    fi
    TASK=$1
    printf "${BLUE}[ ] ${TASK}${NC}\n"
}

function _task_done {
    printf "${OVERWRITE}${CHECK_MARK} ${GREEN}${TASK}${NC}\n"
    TASK=""
}

function _task_error {
    printf "${OVERWRITE}${X_MARK} ${RED}${TASK} - ERROR${NC}\n"
    echo -e "${RED}$1${NC}"
    exit 1
}

# Command execution with error handling
function _cmd {
    if ! eval "$1" >/dev/null 2>&1; then
        _task_error "Command failed: $1"
    fi
}

# Command execution with output
function _cmd_with_output {
    if ! eval "$1"; then
        _task_error "Command failed: $1"
    fi
}

# Detect OS
function detect_os {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        echo $ID
    else
        echo "unknown"
    fi
}

# Check if running in WSL
function is_wsl {
    if [[ -n "${WSL_DISTRO_NAME}" ]] || [[ -n "${WSLENV}" ]] || [[ "$(uname -r)" == *microsoft* ]]; then
        return 0
    else
        return 1
    fi
}

# Get Windows username
function get_windows_username {
    if is_wsl; then
        # Try multiple methods to get Windows username
        local win_user=""

        # Method 1: From WSL environment
        if [[ -n "$WSLENV" ]]; then
            win_user=$(powershell.exe -Command '$env:USERNAME' 2>/dev/null | tr -d '\r\n' || echo "")
        fi

        # Method 2: From Windows registry via cmd
        if [[ -z "$win_user" ]]; then
            win_user=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r\n' || echo "")
        fi

        # Method 3: Parse from current WSL path
        if [[ -z "$win_user" ]] && [[ -d "/mnt/c/Users" ]]; then
            local users_dir="/mnt/c/Users"
            local possible_users=($(ls "$users_dir" 2>/dev/null | grep -v "Public\|Default\|All Users" || echo ""))
            if [[ ${#possible_users[@]} -eq 1 ]]; then
                win_user="${possible_users[0]}"
            elif [[ ${#possible_users[@]} -gt 1 ]]; then
                echo -e "${YELLOW}Multiple Windows users found. Please select:${NC}"
                for i in "${!possible_users[@]}"; do
                    echo "$((i+1)). ${possible_users[$i]}"
                done
                read -p "Enter choice (1-${#possible_users[@]}): " -n 1 -r
                echo
                if [[ $REPLY -ge 1 ]] && [[ $REPLY -le ${#possible_users[@]} ]]; then
                    win_user="${possible_users[$((REPLY-1))]}"
                fi
            fi
        fi

        echo "$win_user"
    fi
}

# Find Windows SSH directory
function find_windows_ssh_dir {
    if is_wsl; then
        local win_user=$(get_windows_username)
        if [[ -n "$win_user" ]]; then
            local possible_paths=(
                "/mnt/c/Users/$win_user/.ssh"
                "/mnt/c/Users/$win_user/AppData/Roaming/openssh"
                "/mnt/c/ProgramData/ssh"
            )

            for path in "${possible_paths[@]}"; do
                if [[ -d "$path" ]]; then
                    echo "$path"
                    return 0
                fi
            done
        fi
    fi
    return 1
}

# List Windows SSH keys
function list_windows_ssh_keys {
    local windows_ssh_dir="$1"
    if [[ -d "$windows_ssh_dir" ]]; then
        find "$windows_ssh_dir" -name "id_*" -not -name "*.pub" 2>/dev/null || echo ""
    fi
}

# Check if Windows SSH keys exist
function check_windows_ssh_keys {
    if is_wsl; then
        __task "Checking for existing Windows SSH keys"

        WINDOWS_SSH_DIR=$(find_windows_ssh_dir)
        if [[ -n "$WINDOWS_SSH_DIR" ]]; then
            local ssh_keys=($(list_windows_ssh_keys "$WINDOWS_SSH_DIR"))
            if [[ ${#ssh_keys[@]} -gt 0 ]]; then
                echo -e "${GREEN}Found Windows SSH directory: $WINDOWS_SSH_DIR${NC}"
                echo -e "${GREEN}Found SSH keys:${NC}"
                for key in "${ssh_keys[@]}"; do
                    echo -e "  ${BLUE}$(basename "$key")${NC}"
                done
                _task_done
                return 0
            fi
        fi

        echo -e "${YELLOW}No existing Windows SSH keys found${NC}"
        _task_done
        return 1
    fi
    return 1
}

# Link Windows SSH keys to WSL
function link_windows_ssh_keys {
    local windows_ssh_dir="$1"
    local ssh_keys=($(list_windows_ssh_keys "$windows_ssh_dir"))

    if [[ ${#ssh_keys[@]} -eq 0 ]]; then
        return 1
    fi

    __task "Linking Windows SSH keys to WSL"

    # Create WSL .ssh directory
    mkdir -p "$HOME/.ssh"
    chmod 700 "$HOME/.ssh"

    # If multiple keys, let user choose
    local selected_key=""
    if [[ ${#ssh_keys[@]} -eq 1 ]]; then
        selected_key="${ssh_keys[0]}"
    else
        echo -e "${YELLOW}Multiple SSH keys found. Please select one:${NC}"
        for i in "${!ssh_keys[@]}"; do
            echo "$((i+1)). $(basename "${ssh_keys[$i]}")"
        done
        read -p "Enter choice (1-${#ssh_keys[@]}): " -n 1 -r
        echo
        if [[ $REPLY -ge 1 ]] && [[ $REPLY -le ${#ssh_keys[@]} ]]; then
            selected_key="${ssh_keys[$((REPLY-1))]}"
        else
            _task_error "Invalid selection"
        fi
    fi

    if [[ -n "$selected_key" ]]; then
        local key_name=$(basename "$selected_key")
        local pub_key="${selected_key}.pub"

        # Copy private key
        cp "$selected_key" "$HOME/.ssh/$key_name"
        chmod 600 "$HOME/.ssh/$key_name"

        # Copy public key if it exists
        if [[ -f "$pub_key" ]]; then
            cp "$pub_key" "$HOME/.ssh/${key_name}.pub"
            chmod 644 "$HOME/.ssh/${key_name}.pub"
        fi

        # Update SSH_KEY_PATH to point to the linked key
        SSH_KEY_PATH="$HOME/.ssh/$key_name"

        echo -e "${GREEN}Successfully linked SSH key: $key_name${NC}"
        _task_done
        return 0
    fi

    return 1
}

# Setup SSH in Windows (guide user through it)
function setup_windows_ssh_keys {
    echo -e "\n${ARROW} ${BLUE}Setting up SSH keys in Windows...${NC}\n"

    echo -e "${YELLOW}We'll help you set up SSH keys in Windows and then link them to WSL.${NC}"
    echo -e "${BLUE}Please follow these steps in a Windows PowerShell or Command Prompt:${NC}\n"

    local win_user=$(get_windows_username)
    local suggested_email=""

    echo -e "${BLUE}1. Open PowerShell as your regular user (not as administrator)${NC}"
    echo -e "${BLUE}2. Run the following command to generate an SSH key:${NC}"

    read -p "Enter your email for the SSH key: " suggested_email

    echo -e "\n${GREEN}ssh-keygen -t ed25519 -C \"$suggested_email\"${NC}\n"

    echo -e "${BLUE}3. When prompted for file location, press Enter to use default${NC}"
    echo -e "${BLUE}4. When prompted for passphrase, you can press Enter for no passphrase${NC}"
    echo -e "${BLUE}5. The key will be saved to: C:\\Users\\$win_user\\.ssh\\${NC}\n"

    echo -e "${YELLOW}After generating the key in Windows:${NC}"
    echo -e "${BLUE}6. Copy the PUBLIC key content with this command in PowerShell:${NC}"
    echo -e "${GREEN}Get-Content ~\\.ssh\\id_ed25519.pub | Set-Clipboard${NC}\n"
    echo -e "${BLUE}7. Add the key to GitHub at: https://github.com/settings/keys${NC}\n"

    read -p "Press Enter when you've completed the SSH key setup in Windows..."

    # Now try to find and link the keys
    if check_windows_ssh_keys && [[ -n "$WINDOWS_SSH_DIR" ]]; then
        if link_windows_ssh_keys "$WINDOWS_SSH_DIR"; then
            return 0
        fi
    fi

    echo -e "${RED}Could not find the Windows SSH keys. Please ensure they were created correctly.${NC}"
    return 1
}

# Ubuntu setup
function ubuntu_setup {
    __task "Updating package lists"
    _cmd "sudo apt-get update"

    if ! command -v ansible >/dev/null 2>&1; then
        __task "Installing Ansible"
        _cmd "sudo apt-get install -y software-properties-common"
        _cmd "sudo apt-add-repository -y ppa:ansible/ansible"
        _cmd "sudo apt-get update"
        _cmd "sudo apt-get install -y ansible"
    fi

    if ! command -v git >/dev/null 2>&1; then
        __task "Installing Git"
        _cmd "sudo apt-get install -y git"
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        __task "Installing Python3"
        _cmd "sudo apt-get install -y python3 python3-pip"
    fi

    # Install clipboard utilities
    if ! command -v xclip >/dev/null 2>&1 && ! command -v xsel >/dev/null 2>&1; then
        __task "Installing clipboard utilities"
        _cmd "sudo apt-get install -y xclip"
    fi
}

# Arch/Endeavour setup
function arch_setup {
    __task "Updating package database"
    _cmd "sudo pacman -Sy --noconfirm"

    if ! command -v ansible >/dev/null 2>&1; then
        __task "Installing Ansible"
        _cmd "sudo pacman -S --noconfirm ansible"
    fi

    if ! command -v git >/dev/null 2>&1; then
        __task "Installing Git"
        _cmd "sudo pacman -S --noconfirm git"
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        __task "Installing Python"
        _cmd "sudo pacman -S --noconfirm python python-pip"
    fi

    # Install clipboard utilities
    if ! command -v xclip >/dev/null 2>&1 && ! command -v xsel >/dev/null 2>&1; then
        __task "Installing clipboard utilities"
        _cmd "sudo pacman -S --noconfirm xclip"
    fi
}

# Generate SSH key
function generate_ssh_key {
    if [[ -f "$SSH_KEY_PATH" ]]; then
        echo -e "${YELLOW}SSH key already exists at $SSH_KEY_PATH${NC}"
        read -p "Do you want to use the existing key? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            read -p "Enter a new SSH key name (without path): " key_name
            SSH_KEY_PATH="$HOME/.ssh/$key_name"
        fi
    fi

    if [[ ! -f "$SSH_KEY_PATH" ]]; then
        __task "Generating SSH key"
        read -p "Enter your email for the SSH key: " email

        # Create .ssh directory if it doesn't exist
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"

        # Generate SSH key
        ssh-keygen -t ed25519 -C "$email" -f "$SSH_KEY_PATH" -N ""
        chmod 600 "$SSH_KEY_PATH"
        chmod 644 "${SSH_KEY_PATH}.pub"
        _task_done
    fi
}

# Copy SSH key to clipboard
function copy_ssh_key_to_clipboard {
    __task "Copying SSH public key to clipboard"

    if is_wsl; then
        # WSL - copy to Windows clipboard
        if command -v clip.exe >/dev/null 2>&1; then
            cat "${SSH_KEY_PATH}.pub" | clip.exe
            echo -e "${GREEN}SSH key copied to Windows clipboard via clip.exe${NC}"
        elif command -v powershell.exe >/dev/null 2>&1; then
            cat "${SSH_KEY_PATH}.pub" | powershell.exe -Command "Set-Clipboard"
            echo -e "${GREEN}SSH key copied to Windows clipboard via PowerShell${NC}"
        else
            echo -e "${YELLOW}Could not access Windows clipboard. Please copy manually:${NC}"
            cat "${SSH_KEY_PATH}.pub"
        fi
    else
        # Regular Linux
        if command -v xclip >/dev/null 2>&1; then
            cat "${SSH_KEY_PATH}.pub" | xclip -selection clipboard
            echo -e "${GREEN}SSH key copied to clipboard via xclip${NC}"
        elif command -v xsel >/dev/null 2>&1; then
            cat "${SSH_KEY_PATH}.pub" | xsel --clipboard --input
            echo -e "${GREEN}SSH key copied to clipboard via xsel${NC}"
        else
            echo -e "${YELLOW}No clipboard utility available. Please copy manually:${NC}"
            cat "${SSH_KEY_PATH}.pub"
        fi
    fi
    _task_done
}

# Setup SSH agent
function setup_ssh_agent {
    __task "Setting up SSH agent"

    # Start ssh-agent if not running
    if [[ -z "$SSH_AUTH_SOCK" ]]; then
        eval "$(ssh-agent -s)" >/dev/null
    fi

    # Add key to ssh-agent
    ssh-add "$SSH_KEY_PATH" >/dev/null 2>&1
    _task_done
}

# Wait for user to add SSH key to GitHub
function wait_for_github_setup {
    echo -e "\n${ARROW} ${YELLOW}Please add your SSH key to GitHub:${NC}"
    echo -e "${BLUE}1. Go to https://github.com/settings/keys${NC}"
    echo -e "${BLUE}2. Click 'New SSH key'${NC}"
    echo -e "${BLUE}3. Paste the key from your clipboard${NC}"
    echo -e "${BLUE}4. Give it a meaningful title${NC}"
    echo -e "${BLUE}5. Click 'Add SSH key'${NC}"

    echo
    read -p "Press Enter when you've added the SSH key to GitHub..."
}

# Test SSH connection to GitHub
function test_github_ssh {
    __task "Testing SSH connection to GitHub"

    # Test SSH connection
    if ssh -T git@github.com -o StrictHostKeyChecking=no 2>&1 | grep -q "successfully authenticated"; then
        echo -e "${GREEN}SSH connection to GitHub successful!${NC}"
        _task_done
        return 0
    else
        echo -e "${RED}SSH connection to GitHub failed.${NC}"
        echo -e "${YELLOW}Please check that you've added the SSH key to your GitHub account.${NC}"
        return 1
    fi
}

# Convert repository to SSH if it exists and is HTTPS
function convert_repo_to_ssh {
    if [[ -d "$DOTFILES_DIR" ]]; then
        cd "$DOTFILES_DIR"
        current_remote=$(git remote get-url origin 2>/dev/null || echo "")

        if [[ "$current_remote" == "https://github.com/"* ]]; then
            __task "Converting repository remote from HTTPS to SSH"
            _cmd "git remote set-url origin $DOTFILES_REPO_SSH"
            _task_done
        fi
    fi
}

# WSL SSH setup workflow
function setup_wsl_ssh {
    echo -e "\n${ARROW} ${BLUE}WSL SSH Setup Options:${NC}\n"

    local has_windows_keys=false
    if check_windows_ssh_keys; then
        has_windows_keys=true
    fi

    if [[ "$has_windows_keys" == "true" ]]; then
        echo -e "${GREEN}Found existing Windows SSH keys!${NC}"
        echo -e "${BLUE}1. Link existing Windows SSH keys to WSL${NC}"
        echo -e "${BLUE}2. Create new SSH keys in Windows${NC}"
        echo -e "${BLUE}3. Create new SSH keys directly in WSL${NC}"
        echo
        read -p "Choose an option (1-3): " -n 1 -r
        echo

        case $REPLY in
            1)
                if link_windows_ssh_keys "$WINDOWS_SSH_DIR"; then
                    setup_ssh_agent
                    copy_ssh_key_to_clipboard
                    wait_for_github_setup
                    return 0
                else
                    echo -e "${RED}Failed to link Windows SSH keys${NC}"
                    return 1
                fi
                ;;
            2)
                setup_windows_ssh_keys
                setup_ssh_agent
                copy_ssh_key_to_clipboard
                wait_for_github_setup
                return 0
                ;;
            3)
                generate_ssh_key
                setup_ssh_agent
                copy_ssh_key_to_clipboard
                wait_for_github_setup
                return 0
                ;;
            *)
                echo -e "${RED}Invalid option${NC}"
                return 1
                ;;
        esac
    else
        echo -e "${YELLOW}No existing Windows SSH keys found.${NC}"
        echo -e "${BLUE}1. Create new SSH keys in Windows (recommended for WSL)${NC}"
        echo -e "${BLUE}2. Create new SSH keys directly in WSL${NC}"
        echo
        read -p "Choose an option (1-2): " -n 1 -r
        echo

        case $REPLY in
            1)
                setup_windows_ssh_keys
                setup_ssh_agent
                copy_ssh_key_to_clipboard
                wait_for_github_setup
                return 0
                ;;
            2)
                generate_ssh_key
                setup_ssh_agent
                copy_ssh_key_to_clipboard
                wait_for_github_setup
                return 0
                ;;
            *)
                echo -e "${RED}Invalid option${NC}"
                return 1
                ;;
        esac
    fi
}

# SSH setup workflow
function setup_ssh {
    if is_wsl; then
        setup_wsl_ssh
    else
        echo -e "\n${ARROW} ${BLUE}Setting up SSH for GitHub...${NC}\n"
        generate_ssh_key
        setup_ssh_agent
        copy_ssh_key_to_clipboard
        wait_for_github_setup
    fi

    # Test SSH connection with retries
    local retries=3
    while [[ $retries -gt 0 ]]; do
        if test_github_ssh; then
            break
        else
            retries=$((retries - 1))
            if [[ $retries -gt 0 ]]; then
                echo -e "${YELLOW}Retrying in 5 seconds... ($retries attempts left)${NC}"
                sleep 5
            else
                _task_error "Could not establish SSH connection to GitHub after multiple attempts"
            fi
        fi
    done
}

# Main execution
function main {
    echo -e "${ARROW} ${BLUE}Starting dotfiles setup...${NC}\n"

    # Detect OS
    OS=$(detect_os)
    __task "Detected OS: $OS"
    if is_wsl; then
        echo -e "${BLUE}Running in WSL environment${NC}"
    fi
    _task_done

    # Setup based on OS
    case $OS in
        ubuntu)
            ubuntu_setup
            ;;
        endeavouros|arch)
            arch_setup
            ;;
        *)
            _task_error "Unsupported OS: $OS. This script only supports Ubuntu and Endeavour OS (Arch)."
            ;;
    esac

    # Ask user if they want to setup SSH
    echo
    read -p "Do you want to setup SSH keys for GitHub? (Y/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        setup_ssh
        USE_SSH=true
    else
        USE_SSH=false
    fi

    # Clone or update dotfiles repository
    if [[ ! -d "$DOTFILES_DIR" ]]; then
        __task "Cloning dotfiles repository"
        if [[ "$USE_SSH" == "true" ]]; then
            _cmd "git clone $DOTFILES_REPO_SSH $DOTFILES_DIR"
        else
            _cmd "git clone $DOTFILES_REPO_HTTPS $DOTFILES_DIR"
        fi
    else
        # Convert to SSH if user set up SSH
        if [[ "$USE_SSH" == "true" ]]; then
            convert_repo_to_ssh
        fi

        __task "Updating dotfiles repository"
        _cmd "git -C $DOTFILES_DIR pull"
    fi
    _task_done

    # Change to dotfiles directory
    cd "$DOTFILES_DIR"

    # Install Ansible Galaxy requirements if they exist
    if [[ -f "requirements.yml" ]]; then
        __task "Installing Ansible Galaxy requirements"
        _cmd "ansible-galaxy install -r requirements.yml"
        _task_done
    fi

    # Run the Ansible playbook
    __task "Running Ansible playbook"
    if [[ -f "main.yml" ]]; then
        ansible-playbook main.yml --ask-become-pass "$@"
    elif [[ -f "playbook.yml" ]]; then
        ansible-playbook playbook.yml --ask-become-pass "$@"
    elif [[ -f "site.yml" ]]; then
        ansible-playbook site.yml --ask-become-pass "$@"
    else
        _task_error "No playbook found (main.yml, playbook.yml, or site.yml)"
    fi
    _task_done

    echo -e "\n${CHECK_MARK} ${GREEN}Dotfiles setup completed successfully!${NC}"
    echo -e "${ARROW} ${YELLOW}You may need to restart your shell or reboot to see all changes.${NC}"
    echo -e "${ARROW} ${BLUE}Tmux reminder: Start tmux and press Ctrl+s then I to install plugins${NC}"

    if [[ "$USE_SSH" == "true" ]]; then
        echo -e "${ARROW} ${GREEN}SSH is now configured for GitHub operations${NC}"
    fi
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
    echo -e "${X_MARK} ${RED}Don't run this script as root!${NC}"
    exit 1
fi

# Run main function
main "$@"
