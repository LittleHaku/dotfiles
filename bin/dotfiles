#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status.

# --- Configuration ---
# These are defaults. The cloned repo's script might have different values if you change them there.
DOTFILES_DIR_DEFAULT="$HOME/dotfiles"
DOTFILES_REPO_HTTPS_DEFAULT="https://github.com/LittleHaku/dotfiles.git"
DOTFILES_REPO_SSH_DEFAULT="git@github.com:LittleHaku/dotfiles.git" # Ensure this matches your repo

# --- Bootstrap for curl | bash ---
# This section ensures that if the script is run via curl, it first clones the full repo
# and then re-executes itself from the cloned repo, so it can access library files.

# Try to determine the script's own directory to find lib files.
# This is robust for local execution and when executed from a cloned repo.
# For `curl | bash`, BASH_SOURCE[0] might be /dev/fd/63 or similar.
CURRENT_SCRIPT_PATH="${BASH_SOURCE[0]}"
# Resolve symlinks to get the true script path
while [[ -L "$CURRENT_SCRIPT_PATH" ]]; do
    CURRENT_SCRIPT_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT_PATH")" >/dev/null 2>&1 && pwd)"
    CURRENT_SCRIPT_PATH="$(readlink "$CURRENT_SCRIPT_PATH")"
    [[ "$CURRENT_SCRIPT_PATH" != /* ]] && CURRENT_SCRIPT_PATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_PATH"
done
SCRIPT_REAL_DIR="$(cd -P "$(dirname "$CURRENT_SCRIPT_PATH")" >/dev/null 2>&1 && pwd)"
LIB_DIR_RELATIVE_PATH="../lib" # Relative path from bin/ to lib/
PROBE_LIB_FILE="utils.sh"      # A file we expect to find in the lib directory

# Construct the absolute path to the library directory
# This handles cases where SCRIPT_REAL_DIR might be like /usr/local/bin if symlinked
# We assume the 'lib' directory is relative to the *source* location of the script,
# typically within the dotfiles repository structure.
# If this script (`bin/dotfiles`) is at `REPO_ROOT/bin/dotfiles`, then `lib` is at `REPO_ROOT/lib`.
ABSOLUTE_LIB_DIR="$SCRIPT_REAL_DIR/$LIB_DIR_RELATIVE_PATH"

# Check if we are in a "bootstrapping" phase (lib dir not found relative to script's real location)
# This indicates `curl | bash` or a broken installation.
if [[ ! -f "$ABSOLUTE_LIB_DIR/$PROBE_LIB_FILE" ]]; then
    echo -e "\033[1;33mBootstrapping: Library files not found at $ABSOLUTE_LIB_DIR.\033[0m"
    echo -e "\033[1;33mAssuming curl | bash execution or incomplete setup.\033[0m"
    echo -e "\033[0;34mAttempting to clone/update dotfiles repository to $DOTFILES_DIR_DEFAULT...\033[0m"

    # Minimal dependencies for cloning: Git
    if ! command -v git &>/dev/null; then
        echo "Git not found. Attempting to install..."
        if command -v apt-get &>/dev/null; then
            sudo apt-get update && sudo apt-get install -y git
        elif command -v pacman &>/dev/null; then
            sudo pacman -Sy --noconfirm git
        elif command -v dnf &>/dev/null; then # Fedora
            sudo dnf install -y git
        elif command -v yum &>/dev/null; then # CentOS/RHEL older
            sudo yum install -y git
        elif command -v zypper &>/dev/null; then # OpenSUSE
            sudo zypper install -y git
        else
            echo -e "\033[0;31mError: Could not install Git. Please install Git manually and re-run.\033[0m" >&2
            exit 1
        fi
        if ! command -v git &>/dev/null; then # Check again
            echo -e "\033[0;31mError: Git installation failed. Please install Git manually and re-run.\033[0m" >&2
            exit 1
        fi
    fi

    if [[ -d "$DOTFILES_DIR_DEFAULT/.git" ]]; then
        echo "Dotfiles directory $DOTFILES_DIR_DEFAULT already exists and is a Git repository. Pulling latest changes..."
        current_pwd_bootstrap=$(pwd)
        cd "$DOTFILES_DIR_DEFAULT" || (echo "Failed to cd to $DOTFILES_DIR_DEFAULT" && exit 1)
        git pull || (echo "Git pull failed in $DOTFILES_DIR_DEFAULT" && exit 1)
        cd "$current_pwd_bootstrap" || (echo "Failed to cd back to $current_pwd_bootstrap" && exit 1)
    else
        echo "Cloning $DOTFILES_REPO_HTTPS_DEFAULT into $DOTFILES_DIR_DEFAULT..."
        # Remove if it exists but is not a git repo, or is an empty dir
        if [[ -e "$DOTFILES_DIR_DEFAULT" ]]; then
            rm -rf "$DOTFILES_DIR_DEFAULT"
        fi
        git clone "$DOTFILES_REPO_HTTPS_DEFAULT" "$DOTFILES_DIR_DEFAULT" || (echo "Git clone failed" && exit 1)
    fi

    # Re-execute the script from the cloned repository's bin directory
    CLONED_SCRIPT_PATH="$DOTFILES_DIR_DEFAULT/bin/dotfiles"
    if [[ -f "$CLONED_SCRIPT_PATH" ]]; then
        echo -e "\033[0;32mBootstrap complete. Re-executing script from $CLONED_SCRIPT_PATH...\033[0m"
        # Pass along any original arguments
        exec bash "$CLONED_SCRIPT_PATH" "$@"
        # exec replaces the current shell, so script doesn't continue here if successful
        echo -e "\033[0;31mError: exec failed for $CLONED_SCRIPT_PATH\033[0m" >&2
        exit 1 # Should not be reached if exec succeeds
    else
        echo -e "\033[0;31mError: Cloned script not found at $CLONED_SCRIPT_PATH.\033[0m" >&2
        echo -e "\033[0;31mPlease check the repository structure and clone manually if needed.\033[0m" >&2
        exit 1
    fi
fi
# --- End of Bootstrap section ---

# --- Regular script execution starts here ---
# If we reached here, lib files are accessible. SCRIPT_REAL_DIR and ABSOLUTE_LIB_DIR are set.

# Global variables (can be overridden by sourced files if they also declare them, so be mindful)
# These will now use the values from the (potentially cloned) repository context.
DOTFILES_DIR="$HOME/dotfiles" # Standard location
DOTFILES_REPO_HTTPS="https://github.com/LittleHaku/dotfiles.git" # Standard HTTPS remote
DOTFILES_REPO_SSH="git@github.com:LittleHaku/dotfiles.git"     # Standard SSH remote
SSH_KEY_PATH="$HOME/.ssh/id_ed25519" # Default SSH key path, can be changed by SSH setup functions
WINDOWS_SSH_DIR=""                   # Populated by WSL functions if applicable
TASK=""                              # For task management UI
USE_SSH=false                        # Flag to indicate if SSH should be used for Git operations

# Source library files using the determined ABSOLUTE_LIB_DIR
# Order matters if there are dependencies between them. utils.sh is usually first.
source "$ABSOLUTE_LIB_DIR/utils.sh"
source "$ABSOLUTE_LIB_DIR/os_detect.sh"
source "$ABSOLUTE_LIB_DIR/ssh_setup.sh"
source "$ABSOLUTE_LIB_DIR/package_manager.sh"
source "$ABSOLUTE_LIB_DIR/main_logic.sh" # This contains the main_execution function

# Check if running as root (after sourcing utils for X_MARK and RED)
if [[ $EUID -eq 0 ]]; then
    echo -e "${X_MARK} ${RED}Don't run this script as root! It will use 'sudo' where necessary.${NC}" >&2
    exit 1
fi

# Run the main execution logic, passing all script arguments
main_execution "$@"
